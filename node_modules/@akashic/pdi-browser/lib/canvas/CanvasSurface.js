"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.CanvasSurface = void 0;
var g = require("@akashic/akashic-engine");
var Context2DRenderer_1 = require("./Context2DRenderer");
var CanvasSurface = /** @class */ (function (_super) {
    __extends(CanvasSurface, _super);
    function CanvasSurface(width, height) {
        var _this = this;
        var canvas = document.createElement("canvas");
        _this = _super.call(this, width, height, canvas) || this;
        canvas.width = width;
        canvas.height = height;
        _this.canvas = canvas;
        _this._context = canvas.getContext("2d");
        _this._renderer = undefined;
        return _this;
    }
    CanvasSurface.prototype.destroy = function () {
        this.canvas.width = 1;
        this.canvas.height = 1;
        this.canvas = null;
        this._renderer = null;
        _super.prototype.destroy.call(this);
    };
    CanvasSurface.prototype.renderer = function () {
        if (!this._renderer) {
            this._renderer = new Context2DRenderer_1.Context2DRenderer(this, this._context);
        }
        return this._renderer;
    };
    CanvasSurface.prototype.getHTMLElement = function () {
        return this.canvas;
    };
    /**
     * 描き込み時の拡大率(と描画領域のサイズ)を変更する。
     * このメソッドによって描画領域のサイズは変化し、それにより表示上のサイズも変化するが、
     * 「ゲームコンテンツから見たサーフェスとしてのサイズ」(生成時に指定されたサイズ)は変わらない点に注意。
     *
     * このメソッドと `changeVisualScale()` との違いは、拡大時、高解像度の画像の縮小して描き込む時に現れる。
     * このメソッドによる拡大は、表示上の拡大率のみを変更する `changeVisualScale()` と異なり、
     * 「縮小と拡大の変換行列をかけて大きなcanvasに描き込む」ことになるため、描画元の解像度を活かすことができる。
     *
     * このメソッドは、このサーフェスへの描画中(`this.renderer().begin()` から `end()` までの間)に呼び出してはならない。
     */
    CanvasSurface.prototype.changePhysicalScale = function (xScale, yScale) {
        this.canvas.width = this.width * xScale;
        this.canvas.height = this.height * yScale;
        this._context.scale(xScale, yScale);
    };
    /**
     * 表示上の拡大率を変更する。
     * `changeRawSize()` との差異に注意。
     */
    CanvasSurface.prototype.changeVisualScale = function (xScale, yScale) {
        /*
         Canvas要素のリサイズをCSS transformで行う。
         CSSのwidth/height styleによるリサイズはおかしくなるケースが存在するので、可能な限りtransformを使う。
         - https://twitter.com/uupaa/status/639002317576998912
         - http://havelog.ayumusato.com/develop/performance/e554-paint_gpu_acceleration_problems.html
         - http://buccchi.jp/blog/2013/03/android_canvas_deathpoint/
         */
        var canvasStyle = this.canvas.style;
        if ("transform" in canvasStyle) {
            canvasStyle.transformOrigin = "0 0";
            canvasStyle.transform = "scale(" + xScale + "," + yScale + ")";
        }
        else if ("webkitTransform" in canvasStyle) {
            canvasStyle.webkitTransformOrigin = "0 0";
            canvasStyle.webkitTransform = "scale(" + xScale + "," + yScale + ")";
        }
        else {
            canvasStyle.width = Math.floor(xScale * this.width) + "px";
            canvasStyle.height = Math.floor(yScale * this.width) + "px";
        }
    };
    CanvasSurface.prototype.isPlaying = function () {
        throw g.ExceptionFactory.createAssertionError("CanvasSurface#isPlaying() is not implemented");
    };
    return CanvasSurface;
}(g.Surface));
exports.CanvasSurface = CanvasSurface;
