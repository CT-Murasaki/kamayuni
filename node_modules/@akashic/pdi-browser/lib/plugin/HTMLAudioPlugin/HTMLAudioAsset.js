"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.HTMLAudioAsset = void 0;
var g = require("@akashic/akashic-engine");
var HTMLAudioAsset = /** @class */ (function (_super) {
    __extends(HTMLAudioAsset, _super);
    function HTMLAudioAsset() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    HTMLAudioAsset.prototype._load = function (loader) {
        var _this = this;
        if (this.path == null) {
            // 再生可能な形式がない。実際には鳴らない音声としてロード成功しておく
            this.data = null;
            setTimeout(function () { return loader._onAssetLoad(_this); }, 0);
            return;
        }
        var audio = new Audio();
        var startLoadingAudio = function (path, handlers) {
            // autoplay は preload よりも優先されるため明示的にfalseとする
            audio.autoplay = false;
            audio.preload = "none";
            audio.src = path;
            _this._attachAll(audio, handlers);
            /* tslint:disable */
            // Firefoxはpreload="auto"でないと読み込みされない
            // preloadはブラウザに対するHint属性なので、どう扱うかはブラウザの実装次第となる
            // https://html.spec.whatwg.org/multipage/embedded-content.html#attr-media-preload
            // https://developer.mozilla.org/ja/docs/Web/HTML/Element/audio#attr-preload
            // https://github.com/CreateJS/SoundJS/blob/e2d4842a84ff425ada861edb9f6e9b57f63d7caf/src/soundjs/htmlaudio/HTMLAudioSoundInstance.js#L147-147
            /* tslint:enable:max-line-length */
            audio.preload = "auto";
            setAudioLoadInterval(audio, handlers);
            audio.load();
        };
        var handlers = {
            success: function () {
                _this._detachAll(audio, handlers);
                _this.data = audio;
                loader._onAssetLoad(_this);
                window.clearInterval(_this._intervalId);
            },
            error: function () {
                _this._detachAll(audio, handlers);
                _this.data = audio;
                loader._onAssetError(_this, g.ExceptionFactory.createAssetLoadError("HTMLAudioAsset loading error"));
                window.clearInterval(_this._intervalId);
            }
        };
        var setAudioLoadInterval = function (audio, handlers) {
            // IE11において、canplaythroughイベントが正常に発火しない問題が確認されたため、その対処として以下の処理を行っている。
            // なお、canplaythroughはreadyStateの値が4になった時点で呼び出されるイベントである。
            // インターバルとして指定している100msに根拠は無い。
            _this._intervalCount = 0;
            _this._intervalId = window.setInterval(function () {
                if (audio.readyState === 4) {
                    handlers.success();
                }
                else {
                    ++_this._intervalCount;
                    // readyStateの値が4にならない状態が1分（100ms×600）続いた場合、
                    // 読み込みに失敗したとする。1分という時間に根拠は無い。
                    if (_this._intervalCount === 600) {
                        handlers.error();
                    }
                }
            }, 100);
        };
        // 暫定対応：後方互換性のため、aacファイルが無い場合はmp4へのフォールバックを試みる。
        // この対応を止める際には、HTMLAudioPluginのsupportedExtensionsからaacを除外する必要がある。
        if (this.path.slice(-4) === ".aac" && HTMLAudioAsset.supportedFormats.indexOf("mp4") !== -1) {
            var altHandlers = {
                success: handlers.success,
                error: function () {
                    _this._detachAll(audio, altHandlers);
                    window.clearInterval(_this._intervalId);
                    var altPath = _this.path.slice(0, _this.path.length - 4) + ".mp4";
                    startLoadingAudio(altPath, handlers);
                }
            };
            startLoadingAudio(this.path, altHandlers);
            return;
        }
        startLoadingAudio(this.path, handlers);
    };
    HTMLAudioAsset.prototype.cloneElement = function () {
        return this.data ? new Audio(this.data.src) : null;
    };
    HTMLAudioAsset.prototype._assetPathFilter = function (path) {
        if (HTMLAudioAsset.supportedFormats.indexOf("ogg") !== -1) {
            return g.PathUtil.addExtname(path, "ogg");
        }
        if (HTMLAudioAsset.supportedFormats.indexOf("aac") !== -1) {
            return g.PathUtil.addExtname(path, "aac");
        }
        // ここで検出されるのは最初にアクセスを試みるオーディオアセットのファイルパスなので、
        // supportedFormatsに(後方互換性保持で使う可能性がある)mp4が含まれていても利用しない
        return null;
    };
    HTMLAudioAsset.prototype._attachAll = function (audio, handlers) {
        if (handlers.success) {
            /* tslint:disable:max-line-length */
            // https://developer.mozilla.org/en-US/docs/Web/Events/canplaythrough
            // https://github.com/goldfire/howler.js/blob/1dad25cdd9d6982232050454e8b45411902efe65/howler.js#L372
            // https://github.com/CreateJS/SoundJS/blob/e2d4842a84ff425ada861edb9f6e9b57f63d7caf/src/soundjs/htmlaudio/HTMLAudioSoundInstance.js#L145-145
            /* tslint:enable:max-line-length */
            audio.addEventListener("canplaythrough", handlers.success, false);
        }
        if (handlers.error) {
            // https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Media_events
            // stalledはfetchして取れなかった時に起きるイベント
            audio.addEventListener("stalled", handlers.error, false);
            audio.addEventListener("error", handlers.error, false);
            audio.addEventListener("abort", handlers.error, false);
        }
    };
    HTMLAudioAsset.prototype._detachAll = function (audio, handlers) {
        if (handlers.success) {
            audio.removeEventListener("canplaythrough", handlers.success, false);
        }
        if (handlers.error) {
            audio.removeEventListener("stalled", handlers.error, false);
            audio.removeEventListener("error", handlers.error, false);
            audio.removeEventListener("abort", handlers.error, false);
        }
    };
    return HTMLAudioAsset;
}(g.AudioAsset));
exports.HTMLAudioAsset = HTMLAudioAsset;
