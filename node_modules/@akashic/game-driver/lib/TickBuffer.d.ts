import * as pl from "@akashic/playlog";
import { AMFlow } from "@akashic/amflow";
import * as g from "@akashic/akashic-engine";
import ExecutionMode from "./ExecutionMode";
import StorageOnTick from "./StorageOnTick";
export interface TickBufferParameterObject {
    /**
     * この `TickBuffer` がTickを受け取るための `AMFlow` 。
     */
    amflow: AMFlow;
    /**
     * 実行モード。
     * Passiveの場合、AMFlow からの受信を試みる。
     */
    executionMode: ExecutionMode;
    /**
     * 先読み閾値。
     *
     * 欠けているTickのこの値分手前のTickを消化した時、先回りしてTickの取得を試みる。
     * 省略された場合、 `TickBuffer.DEFAULT_PREFETCH_THRESHOLD` 。
     */
    prefetchThreshold?: number;
    /**
     * 先読み時、一度に要求するTickの数。
     * 省略された場合、 `TickBuffer.DEFAULT_SIZE_REQUEST_ONCE` 。
     */
    sizeRequestOnce?: number;
}
export interface TickRange {
    start: number;
    end: number;
    ticks: pl.Tick[];
}
/**
 * AMFlowから流れ込むTickを蓄積するバッファ。
 *
 * 主に以下を行う。
 * * 受信済みのTickの管理
 * * 現在age・既知の最新age・直近の欠けているTickの管理
 * * 足りなそうなTickの先行リクエスト
 * * 処理済みTickの破棄
 */
export declare class TickBuffer {
    static DEFAULT_PREFETCH_THRESHOLD: number;
    static DEFAULT_SIZE_REQUEST_ONCE: number;
    /**
     * 現在のage。
     * 次に `consume()` した時、このageのTickを返す。
     */
    currentAge: number;
    /**
     * 既知の最新age。
     * AMFlow から受け取った限りで最後のage。
     */
    knownLatestAge: number;
    /**
     * 現在ageのTickを新たに取得したときにfireされる `g.Trigger` 。
     * Tick取得待ちを解除する契機として使える。
     */
    gotNextTickTrigger: g.Trigger<void>;
    /**
     * ストレージを含むTickを取得した時にfireされる `g.Trigger` 。
     */
    gotStorageTrigger: g.Trigger<StorageOnTick>;
    _amflow: AMFlow;
    _prefetchThreshold: number;
    _sizeRequestOnce: number;
    _executionMode: ExecutionMode;
    _receiving: boolean;
    /**
     * 取得したTick。
     */
    _tickRanges: TickRange[];
    /**
     * `currentAge` からもっとも近い、Tickを取得していないage。
     */
    _nearestAbsentAge: number;
    /**
     * `readNextTickTime()` の値のキャッシュ。
     * ティック時刻に到達するまでループの度に確認されるのでキャッシュしておく。
     */
    _nextTickTimeCache: number;
    _addTick_bound: (tick: pl.Tick) => void;
    _onTicks_bound: (err: Error | null, ticks?: pl.TickList) => void;
    constructor(param: TickBufferParameterObject);
    start(): void;
    stop(): void;
    setExecutionMode(execMode: ExecutionMode): void;
    setCurrentAge(age: number): void;
    hasNextTick(): boolean;
    consume(): pl.Tick | number;
    readNextTickTime(): number;
    requestTicks(from?: number, len?: number): void;
    addTick(tick: pl.Tick): void;
    addTickList(tickList: pl.TickList): TickRange;
    _updateAmflowReceiveState(): void;
    _onTicks(err: Error | null, ticks?: pl.TickList): void;
    _findNearestAbscentAge(age: number): number;
    _dropUntil(age: number): void;
    private _createTickRangeFromTick;
}
